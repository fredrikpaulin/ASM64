/*
 * assembler.h - Two-Pass Assembler Core
 * ASM64 - 6502/6510 Assembler for Commodore 64
 */

#ifndef ASSEMBLER_H
#define ASSEMBLER_H

#include <stdint.h>
#include "symbols.h"
#include "parser.h"

/* ========== Constants ========== */

#define ASM_MEMORY_SIZE    65536   /* 64KB address space */
#define ASM_DEFAULT_ORG    0x0801  /* C64 BASIC program start */
#define ASM_MAX_ERRORS     100     /* Stop after this many errors */
#define ASM_MAX_WARNINGS   100     /* Max warnings to report */
#define ASM_MAX_INCLUDE_DEPTH 16   /* Maximum nesting of !source */
#define ASM_MAX_INCLUDE_PATHS 16   /* Maximum include search paths */
#define ASM_MAX_COND_DEPTH    32   /* Maximum nesting of !if */
#define ASM_MAX_MACRO_DEPTH   16   /* Maximum nesting of macro expansion */
#define ASM_MAX_MACRO_ARGS    16   /* Maximum arguments per macro */
#define ASM_MAX_LOOP_DEPTH    32   /* Maximum nesting of !for/!while */

/* ========== Output Format ========== */

typedef enum {
    OUTPUT_PRG,     /* Commodore PRG format (2-byte load address header) */
    OUTPUT_RAW      /* Raw binary, no header */
} OutputFormat;

/* ========== Source Line ========== */

typedef struct {
    char *text;             /* Raw source text */
    const char *filename;   /* Source file */
    int line_number;        /* Line number in file */
} SourceLine;

/* ========== Include Stack Entry ========== */

typedef struct {
    char *filename;         /* Included file name (owned) */
    int line_number;        /* Line number where included */
    char *source;           /* Source content (owned) */
} IncludeEntry;

/* ========== Conditional Assembly State ========== */

typedef struct {
    int active;             /* 1 if this level is assembling code */
    int else_seen;          /* 1 if !else has been encountered */
    int parent_active;      /* 1 if parent level was active */
    const char *filename;   /* File where !if was issued */
    int line_number;        /* Line number of !if */
} CondEntry;

/* ========== Macro Definition ========== */

typedef struct Macro {
    char *name;                 /* Macro name */
    char **params;              /* Parameter names */
    int param_count;            /* Number of parameters */
    char *body;                 /* Macro body text (source lines) */
    const char *filename;       /* File where defined */
    int line_number;            /* Line where defined */
    struct Macro *next;         /* Hash chain */
} Macro;

/* Macro table (hash table of macros) */
typedef struct {
    Macro **buckets;
    int bucket_count;
    int macro_count;
} MacroTable;

/* Macro expansion state */
typedef struct {
    const char *name;           /* Macro being expanded */
    char **arg_values;          /* Argument values for substitution */
    int arg_count;              /* Number of arguments */
    int unique_id;              /* Unique ID for local labels */
} MacroExpansion;

/* ========== Loop State ========== */

typedef enum {
    LOOP_FOR,       /* !for var, start, end { } */
    LOOP_WHILE      /* !while expr { } */
} LoopType;

typedef struct {
    LoopType type;              /* Type of loop */
    char *body;                 /* Loop body text (owned) */
    const char *filename;       /* File where loop started */
    int line_number;            /* Line where loop started */

    /* For !for loops */
    char *var_name;             /* Loop variable name (owned) */
    int32_t current;            /* Current value */
    int32_t end;                /* End value (inclusive) */
    int32_t step;               /* Step value (default 1) */

    /* For !while loops */
    Expr *condition;            /* Condition expression (owned) */
} LoopEntry;

/* ========== Assembled Statement ========== */

/*
 * Stores a parsed statement along with its assembled bytes.
 * Used between pass 1 and pass 2, and for listing generation.
 */
typedef struct {
    Statement *stmt;        /* Parsed statement */
    uint16_t address;       /* Address where this statement is located */
    uint8_t bytes[8];       /* Generated bytes (max 8 for directives) */
    int byte_count;         /* Number of bytes generated */
    int needs_resolution;   /* 1 if has unresolved forward reference */
    char *source_text;      /* Original source line (owned, for listings) */
    int cycles;             /* Cycle count (for listings) */
    int page_penalty;       /* 1 if +1 cycle on page cross */
} AssembledLine;

/* ========== CPU Types ========== */

typedef enum {
    CPU_6502,       /* Standard 6502 (no illegal opcodes) */
    CPU_6510,       /* 6510 with illegal opcodes (default) */
    CPU_65C02       /* 65C02 with extended instructions */
} CpuType;

/* ========== Assembler Context ========== */

typedef struct {
    /* Memory output */
    uint8_t *memory;            /* 64KB output buffer */
    uint8_t *written;           /* Bitmap: 1 if byte has been written */
    uint16_t pc;                /* Current program counter (virtual, for labels) */
    uint16_t real_pc;           /* Real output PC (for !pseudopc) */
    uint16_t org;               /* Origin address */
    uint16_t lowest_addr;       /* Lowest address written */
    uint16_t highest_addr;      /* Highest address written */
    int in_pseudopc;            /* 1 if inside !pseudopc block */

    /* Symbol table */
    SymbolTable *symbols;

    /* Scope tracking for local labels */
    Scope *scope;

    /* Anonymous label tracking */
    AnonLabels *anon_labels;

    /* Assembly state */
    int pass;                   /* Current pass (1 or 2) */
    int errors;                 /* Error count */
    int warnings;               /* Warning count */

    /* Source tracking */
    const char *current_file;   /* Current source filename */
    int current_line;           /* Current line number */

    /* Statement storage for pass 2 */
    AssembledLine *lines;       /* Array of assembled lines */
    int line_count;             /* Number of lines */
    int line_capacity;          /* Allocated capacity */

    /* Output options */
    OutputFormat format;        /* Output file format */
    uint8_t fill_byte;          /* Byte to fill gaps with */
    int verbose;                /* Verbose output mode */
    int show_cycles;            /* Show cycle counts */

    /* Include file handling */
    IncludeEntry include_stack[ASM_MAX_INCLUDE_DEPTH];
    int include_depth;          /* Current nesting depth */
    char *include_paths[ASM_MAX_INCLUDE_PATHS];
    int include_path_count;     /* Number of search paths */

    /* Conditional assembly */
    CondEntry cond_stack[ASM_MAX_COND_DEPTH];
    int cond_depth;             /* Current conditional nesting depth */

    /* Macro handling */
    MacroTable *macros;         /* Defined macros */
    MacroExpansion *macro_stack[ASM_MAX_MACRO_DEPTH];
    int macro_depth;            /* Current macro expansion depth */
    int macro_unique_counter;   /* Counter for unique local labels */

    /* Loop handling */
    LoopEntry *loop_stack[ASM_MAX_LOOP_DEPTH];
    int loop_depth;             /* Current loop nesting depth */

    /* Command-line defined symbols (preserved across reset) */
    char *cmdline_defines[64];
    int cmdline_define_count;

    /* CPU selection */
    CpuType cpu_type;           /* Current CPU type */
} Assembler;

/* Maximum command-line defines */
#define ASM_MAX_CMDLINE_DEFINES 64

/* ========== Assembler Lifecycle ========== */

/*
 * Create a new assembler context.
 * Returns NULL on allocation failure.
 */
Assembler *assembler_create(void);

/*
 * Free an assembler context and all associated resources.
 */
void assembler_free(Assembler *as);

/*
 * Reset assembler state for a new assembly.
 * Clears memory, symbols, errors, etc.
 */
void assembler_reset(Assembler *as);

/* ========== Assembly Functions ========== */

/*
 * Assemble a source file.
 * Returns 0 on success, non-zero on error.
 */
int assembler_assemble_file(Assembler *as, const char *filename);

/*
 * Assemble a source string (for testing).
 * Returns 0 on success, non-zero on error.
 */
int assembler_assemble_string(Assembler *as, const char *source, const char *filename);

/*
 * Run pass 1: Parse source, collect symbols, determine sizes.
 * Returns 0 on success, non-zero on error.
 */
int assembler_pass1(Assembler *as, const char *source, const char *filename);

/*
 * Run pass 2: Generate code, resolve symbols.
 * Returns 0 on success, non-zero on error.
 */
int assembler_pass2(Assembler *as);

/* ========== Output Functions ========== */

/*
 * Write assembled output to file.
 * Returns 0 on success, non-zero on error.
 */
int assembler_write_output(Assembler *as, const char *filename);

/*
 * Write VICE-format symbol file.
 * Returns 0 on success, non-zero on error.
 */
int assembler_write_symbols(Assembler *as, const char *filename);

/*
 * Write listing file.
 * Includes address, hex bytes, source, and optionally cycle counts.
 * Returns 0 on success, non-zero on error.
 */
int assembler_write_listing(Assembler *as, const char *filename);

/*
 * Get assembled bytes.
 * Sets *size to number of bytes and returns pointer to data.
 * Caller must not free the returned pointer.
 */
const uint8_t *assembler_get_output(Assembler *as, uint16_t *start_addr, int *size);

/* ========== Code Emission ========== */

/*
 * Emit a single byte at current PC.
 */
void assembler_emit_byte(Assembler *as, uint8_t byte);

/*
 * Emit a 16-bit word (little-endian) at current PC.
 */
void assembler_emit_word(Assembler *as, uint16_t word);

/*
 * Emit multiple bytes at current PC.
 */
void assembler_emit_bytes(Assembler *as, const uint8_t *bytes, int count);

/*
 * Set the program counter.
 */
void assembler_set_pc(Assembler *as, uint16_t pc);

/*
 * Get the current program counter.
 */
uint16_t assembler_get_pc(Assembler *as);

/* ========== Statement Assembly ========== */

/*
 * Assemble a single statement in the current pass.
 * Returns 0 on success, non-zero on error.
 */
int assembler_assemble_statement(Assembler *as, Statement *stmt);

/*
 * Assemble an instruction statement.
 */
int assembler_assemble_instruction(Assembler *as, Statement *stmt);

/*
 * Assemble a directive statement.
 */
int assembler_assemble_directive(Assembler *as, Statement *stmt);

/* ========== Error Handling ========== */

/*
 * Report an error at the current location.
 */
void assembler_error(Assembler *as, const char *fmt, ...);

/*
 * Report a warning at the current location.
 */
void assembler_warning(Assembler *as, const char *fmt, ...);

/*
 * Check if assembler has errors.
 */
int assembler_has_errors(Assembler *as);

/*
 * Get error count.
 */
int assembler_error_count(Assembler *as);

/*
 * Get warning count.
 */
int assembler_warning_count(Assembler *as);

/* ========== Utility Functions ========== */

/*
 * Calculate relative branch offset.
 * target: absolute target address
 * pc: address of branch instruction
 * Returns signed offset (-128 to +127) or INT_MIN on error.
 */
int assembler_calc_branch_offset(uint16_t target, uint16_t pc);

/*
 * Check if an address is in zero-page.
 */
int assembler_is_zeropage(int32_t addr);

/* ========== Command-Line Symbol Definition ========== */

/*
 * Define a symbol from command line (-D NAME=value or -D NAME).
 * If no '=' is present, symbol is defined with value 1.
 * Returns 0 on success, -1 on error.
 */
int assembler_define_symbol(Assembler *as, const char *definition);

/* ========== Include Path Functions ========== */

/*
 * Add an include search path.
 * Returns 0 on success, -1 if too many paths.
 */
int assembler_add_include_path(Assembler *as, const char *path);

/*
 * Add include paths from environment variable.
 * Parses colon-separated (Unix) or semicolon-separated (Windows) paths.
 */
void assembler_add_include_paths_from_env(Assembler *as, const char *env_var);

/*
 * Search for an include file.
 * Searches: 1) relative to current file, 2) include paths
 * Returns allocated path on success, NULL if not found.
 * Caller must free the result.
 */
char *assembler_find_include(Assembler *as, const char *filename);

/*
 * Include and assemble a source file.
 * Returns 0 on success, -1 on error.
 */
int assembler_include_file(Assembler *as, const char *filename);

/*
 * Include a binary file at current PC.
 * offset: byte offset into file (0 for start)
 * length: bytes to read (0 for entire file from offset)
 * Returns 0 on success, -1 on error.
 */
int assembler_include_binary(Assembler *as, const char *filename,
                             int offset, int length);

/*
 * Get full include stack trace for error messages.
 * Returns newly allocated string, caller must free.
 */
char *assembler_get_include_trace(Assembler *as);

/* ========== Conditional Assembly Functions ========== */

/*
 * Check if assembly is currently active (all conditionals true).
 */
int assembler_is_active(Assembler *as);

/*
 * Handle !if directive - push conditional state.
 * condition: evaluated expression result (0 = false, non-zero = true)
 * Returns 0 on success, -1 on error.
 */
int assembler_cond_if(Assembler *as, int condition);

/*
 * Handle !ifdef directive - push conditional if symbol is defined.
 * Returns 0 on success, -1 on error.
 */
int assembler_cond_ifdef(Assembler *as, const char *symbol_name);

/*
 * Handle !ifndef directive - push conditional if symbol is NOT defined.
 * Returns 0 on success, -1 on error.
 */
int assembler_cond_ifndef(Assembler *as, const char *symbol_name);

/*
 * Handle !else directive - flip conditional state.
 * Returns 0 on success, -1 on error.
 */
int assembler_cond_else(Assembler *as);

/*
 * Handle !endif directive - pop conditional state.
 * Returns 0 on success, -1 on error.
 */
int assembler_cond_endif(Assembler *as);

/* ========== Macro Functions ========== */

/*
 * Create a new macro table.
 */
MacroTable *macro_table_create(int bucket_count);

/*
 * Free a macro table.
 */
void macro_table_free(MacroTable *table);

/*
 * Define a macro.
 * name: macro name
 * params: array of parameter names (will be copied)
 * param_count: number of parameters
 * body: macro body text (will be copied)
 * Returns 0 on success, -1 on error (e.g., duplicate definition).
 */
int macro_define(Assembler *as, const char *name, char **params, int param_count,
                 const char *body, const char *filename, int line_number);

/*
 * Look up a macro by name.
 * Returns macro pointer or NULL if not found.
 */
Macro *macro_lookup(MacroTable *table, const char *name);

/*
 * Expand and assemble a macro invocation.
 * name: macro name
 * args: array of argument strings
 * arg_count: number of arguments
 * Returns 0 on success, -1 on error.
 */
int macro_expand(Assembler *as, const char *name, char **args, int arg_count);

/*
 * Check if currently expanding a macro.
 */
int assembler_in_macro(Assembler *as);

/*
 * Get unique ID for macro-local labels.
 */
int assembler_macro_unique_id(Assembler *as);

/* ========== Loop Functions ========== */

/*
 * Handle !for directive - start a for loop.
 * var_name: loop variable name
 * start: starting value
 * end: ending value (inclusive)
 * body: loop body text
 * Returns 0 on success, -1 on error.
 */
int assembler_loop_for(Assembler *as, const char *var_name,
                       int32_t start, int32_t end, const char *body);

/*
 * Handle !while directive - start a while loop.
 * condition: condition expression (will be copied)
 * body: loop body text
 * Returns 0 on success, -1 on error.
 */
int assembler_loop_while(Assembler *as, Expr *condition, const char *body);

/*
 * Check if currently in a loop.
 */
int assembler_in_loop(Assembler *as);

/*
 * Get current loop variable value (for substitution).
 * Returns the value or 0 if not in a for loop.
 */
int32_t assembler_loop_var_value(Assembler *as, const char *var_name);

/* ========== Pseudo-PC Functions ========== */

/*
 * Enter pseudo-PC mode.
 * Labels and PC references use the pseudo address, but output goes to real_pc.
 * pseudo_addr: the address to use for labels and PC
 * Returns 0 on success, -1 on error.
 */
int assembler_pseudopc_start(Assembler *as, uint16_t pseudo_addr);

/*
 * Exit pseudo-PC mode.
 * Returns to normal PC tracking.
 * Returns 0 on success, -1 on error (if not in pseudopc mode).
 */
int assembler_pseudopc_end(Assembler *as);

/*
 * Check if currently in pseudo-PC mode.
 */
int assembler_in_pseudopc(Assembler *as);

/*
 * Get the real output PC (used for actual byte placement).
 */
uint16_t assembler_get_real_pc(Assembler *as);

/* ========== CPU Selection Functions ========== */

/*
 * Set the CPU type.
 * This affects which opcodes are available.
 * Returns 0 on success, -1 on error (unknown CPU type).
 */
int assembler_set_cpu(Assembler *as, const char *cpu_name);

/*
 * Get the current CPU type.
 */
CpuType assembler_get_cpu(Assembler *as);

/*
 * Check if an opcode is valid for the current CPU.
 * Returns 1 if valid, 0 if not.
 */
int assembler_opcode_valid_for_cpu(Assembler *as, uint8_t opcode);

#endif /* ASSEMBLER_H */
